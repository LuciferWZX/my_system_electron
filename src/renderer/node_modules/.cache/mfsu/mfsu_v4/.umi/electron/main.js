"use strict";
const electron = require("electron");
const url = require("url");
const path$1 = require("path");
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespace(path$1);
const createProtocol = (scheme) => {
  electron.protocol.registerFileProtocol(scheme, (request, respond) => {
    let pathName = new url.URL(request.url).pathname;
    pathName = decodeURI(pathName);
    const filePath = path__namespace.join(__dirname, pathName);
    respond({ path: filePath });
  });
};
const path = require("path");
const fs = require("fs");
let cacheDownItem = {};
const mainWindowIpcStart = (win) => {
  electron.ipcMain.on("toggle_dev_tools", function(event, arg) {
    win.webContents.toggleDevTools();
  });
  electron.ipcMain.on("restart", function() {
    electron.app.relaunch();
    electron.app.exit(0);
  });
  electron.ipcMain.handle("min", function() {
    win.minimize();
  });
  electron.ipcMain.handle("max", function() {
    if (win.isMaximized()) {
      win.unmaximize();
    } else {
      win.maximize();
    }
  });
  electron.ipcMain.handle("close", function() {
    cacheDownItemClose();
    win.close();
  });
  electron.ipcMain.on("set_path", function(e, data = {}) {
    let { path: path2 } = data;
    if (path2) {
      if (path2 !== "not")
        electron.app.setPath("downloads", path2);
      e.reply("set_path", electron.app.getPath("downloads"));
    } else {
      electron.dialog.showOpenDialog({
        title: "\u9009\u62E9\u4E0B\u8F7D\u76EE\u5F55",
        defaultPath: electron.app.getPath("downloads"),
        properties: ["openDirectory"]
      }).then((files) => {
        if (!files.canceled) {
          electron.app.setPath("downloads", files.filePaths[0]);
        }
        e.reply("set_path", files);
      });
    }
  });
  electron.ipcMain.on("check_path", function(e, data = {}) {
    let { path: path2 } = data;
    fs.access(path2, fs.constants.F_OK, (err) => {
      if (!err) {
        electron.shell.showItemInFolder(path2);
      }
      e.reply("check_path" + path2, err);
    });
  });
  electron.ipcMain.on("down-file", function(e, data) {
    let { url: url2 } = data;
    if (!cacheDownItem[url2]) {
      cacheDownItem[url2] = { ...data };
      downFile(url2);
    }
  });
  electron.ipcMain.on("down-file-pause", function(e, data) {
    let { url: url2 } = data;
    let t = cacheDownItem[url2];
    if (t) {
      t._downFileItem.pause();
    }
    e.reply("down-file-pause-" + url2, "\u5DF2\u6682\u505C");
  });
  electron.ipcMain.on("down-file-resume", function(e, data) {
    let { url: url2 } = data;
    let t = cacheDownItem[url2];
    if (t) {
      t._downFileItem.resume();
    }
    e.reply("down-file-resume-" + url2, "\u5DF2\u6062\u590D\u4E0B\u8F7D");
  });
  electron.ipcMain.on("down-file-cancel", function(e, data) {
    let { url: url2 } = data;
    let t = cacheDownItem[url2];
    if (t) {
      t._downFileItem.cancel();
    }
    e.reply("down-file-cancel-" + url2, "\u5DF2\u53D6\u6D88\u4E0B\u8F7D");
  });
  electron.ipcMain.on("resume-download", function(e, data) {
    let { url: url2 } = data;
    let t = cacheDownItem[url2];
    if (t) {
      t._downFileItem.resume();
    } else {
      cacheDownItem[url2] = { ...data };
      resumeDownload(data);
    }
    e.reply("down-file-resume-" + url2, "\u5DF2\u6062\u590D\u4E0B\u8F7D");
  });
  const downFile = (url2) => {
    electron.session.defaultSession.downloadURL(url2);
  };
  const resumeDownload = (obj = {}) => {
    let { path: path2 = "", urlChain = [], offset = 0, length = 0, lastModified, eTag, startTime } = obj;
    if (!path2 || urlChain.length === 0 || length == 0) {
      return;
    }
    electron.session.defaultSession.createInterruptedDownload({
      path: path2,
      urlChain,
      offset,
      length,
      lastModified,
      eTag,
      startTime
    });
  };
  electron.session.defaultSession.on("will-download", (e, item) => {
    try {
      const url2 = item.getURL();
      let cacheItem = cacheDownItem[url2] || {
        notSend: true
      };
      const totalBytes = item.getTotalBytes();
      const filePath = path.join(electron.app.getPath("downloads"), item.getFilename());
      item.setSavePath(filePath);
      cacheItem._downFileItem = item;
      cacheItem.path = item.getSavePath();
      cacheItem.eTag = item.getETag();
      cacheItem.urlChain = item.getURLChain();
      cacheItem.length = totalBytes;
      cacheItem.lastModified = item.getLastModifiedTime();
      cacheItem.startTime = item.getStartTime();
      let lastBytes = 0;
      item.on("updated", (event, state) => {
        if (state === "interrupted") {
          cacheItem.state = "interrupted";
        } else if (state === "progressing") {
          if (item.isPaused()) {
            cacheItem.state = "paused";
          } else {
            let offset = item.getReceivedBytes();
            cacheItem.state = "downing";
            cacheItem.speedBytes = offset - lastBytes;
            cacheItem.progress = parseInt(String(offset / totalBytes * 100));
            cacheItem.offset = offset;
            lastBytes = offset;
          }
        }
        !cacheItem.notSend && win.webContents.send("update-down-state", JSON.parse(JSON.stringify(cacheItem)));
      });
      item.once("done", (event, state) => {
        cacheItem.done = "end";
        switch (state) {
          case "interrupted":
            cacheItem.state = "interrupted-err";
            break;
          case "cancelled":
            cacheItem.state = "cancelled";
            break;
          default:
            cacheItem.state = "completed";
            notification(cacheItem.path);
            break;
        }
        !cacheItem.notSend && win.webContents.send("update-down-state", JSON.parse(JSON.stringify(cacheItem)));
        delete cacheDownItem[url2];
        cacheItem = null;
      });
      if (item.canResume()) {
        item.resume();
      }
    } catch (error) {
      console.log(error);
    }
  });
  const cacheDownItemClose = () => {
    for (let key in cacheDownItem) {
      if (cacheDownItem.hasOwnProperty(key)) {
        let element = cacheDownItem[key];
        if (element._downFileItem) {
          element._downFileItem.pause();
          element._downFileItem = null;
        }
      }
    }
  };
  electron.app.on("gpu-process-crashed", function() {
    cacheDownItemClose();
  });
  electron.app.on("renderer-process-crashed", function() {
    cacheDownItemClose();
  });
  let noti;
  const notification = (url2) => {
    noti = new electron.Notification({
      title: "\u4E0B\u8F7D\u6210\u529F",
      body: url2,
      silent: false,
      icon: url2
    });
    noti.show();
    noti.once("click", () => {
      electron.shell.showItemInFolder(url2);
    });
  };
};
const initPouchDB = async (database) => {
  let databasePath = `log/${database}`;
  if (electron.app.isPackaged) {
    const LOG_PATH = electron.app.getPath("logs");
    databasePath = `${LOG_PATH}/${database}`;
  }
  const PouchDB2 = require("pouchdb");
  const db = new PouchDB2(databasePath);
  const doc = {
    _id: "123",
    name: "dev",
    age: 23,
    designation: "Designer"
  };
  try {
    const res = await db.put(doc);
    console.log("res:", res.rows);
  } catch (e) {
    console.log("exception:", e == null ? void 0 : e.message);
  }
  try {
    const info = await db.info();
    console.log("info:", info);
  } catch (e) {
    console.log("exception:", e);
  }
  await db.close();
};
const PouchDB = require("pouchdb");
PouchDB.plugin(require("pouchdb-find"));
const getPath = (database) => {
  let databasePath = `log/${database}`;
  if (electron.app.isPackaged) {
    const LOG_PATH = electron.app.getPath("logs");
    databasePath = `${LOG_PATH}/${database}`;
  }
  return databasePath;
};
const pouchDBStart = (win) => {
  PouchDB.on("created", function(dbName) {
    console.log(`\u6570\u636E\u5E93:${dbName} \u521B\u5EFA\u6210\u529F.`);
  });
  PouchDB.on("destroyed", function(dbName) {
    console.log(`\u6570\u636E\u5E93:${dbName} \u9500\u6BC1\u6210\u529F.`);
  });
  electron.ipcMain.handle("db_get_all", async (event, dbName) => {
    const db = new PouchDB(getPath(dbName));
    try {
      const res = await db.allDocs({
        include_docs: true
      });
      console.log(`${dbName}\u6240\u6709\u6570\u636E:`, res.rows);
      return res.rows;
    } catch (e) {
      console.log("db_get_all\u51FA\u9519:", e == null ? void 0 : e.message);
    } finally {
      await db.close();
    }
  });
  electron.ipcMain.handle("db_find", async (event, dbName, config) => {
    const db = new PouchDB(getPath(dbName));
    try {
      const res = await db.find(config);
      console.log(`${dbName}\u67E5\u8BE2\u5230\u7684\u6570\u636E:`, res);
      return res.docs;
    } catch (e) {
      console.log("db_find\u51FA\u9519:", e == null ? void 0 : e.message);
    } finally {
      await db.close();
    }
  });
  electron.ipcMain.handle("db_update", async (event, dbName, newData, config) => {
    const db = new PouchDB(getPath(dbName));
    try {
      const res = await db.find(config);
      if (res.docs.length > 0) {
        const result = res.docs[0];
        for (let key in newData) {
          result[key] = newData[key];
        }
        const updateRes = await db.put(result);
        console.log(`${dbName}\u4FEE\u6539\u7684\u6570\u636E:`, updateRes.ok);
        return updateRes.ok;
      }
    } catch (e) {
      console.log("db_update\u51FA\u9519:", e == null ? void 0 : e.message);
    } finally {
      await db.close();
    }
  });
};
let mainWindow = null;
electron.protocol.registerSchemesAsPrivileged([
  { scheme: "app", privileges: { secure: true, standard: true } }
]);
const gotTheLock = electron.app.requestSingleInstanceLock();
if (!gotTheLock) {
  electron.app.quit();
} else {
  const path2 = require("path");
  global.appDirname = __dirname;
  electron.app.commandLine.appendSwitch("disable-features", "OutOfBlinkCors");
  const createWindow = () => {
    const win = new electron.BrowserWindow({
      minWidth: 700,
      minHeight: 500,
      frame: false,
      show: false,
      titleBarStyle: "hidden",
      webPreferences: {
        contextIsolation: true,
        preload: path2.join(__dirname, "preload.js")
      }
    });
    if (electron.app.isPackaged) {
      createProtocol("app");
      const winURL = "app://./index.html";
      win.loadURL(`file://${winURL}`).then();
    } else {
      win.loadURL("http://localhost:8083").then();
      win.webContents.openDevTools();
    }
    initPouchDB("my_db");
    win.on("closed", () => {
      mainWindow = null;
    });
    win.on("ready-to-show", () => {
      win.show();
    });
    return win;
  };
  electron.app.on("ready", () => {
    mainWindow = createWindow();
    pouchDBStart();
    mainWindowIpcStart(mainWindow);
  });
  electron.app.on("second-instance", (event, commandLine, workingDirectory) => {
    if (mainWindow) {
      if (mainWindow.isMinimized())
        mainWindow.restore();
      mainWindow.focus();
    }
  });
  electron.app.on("quit", () => {
    electron.app.releaseSingleInstanceLock();
  });
}
